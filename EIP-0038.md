Partial Voting Hard Fork
===============================

* Author: WilfordGrimley
* Status: Researching (not yet proposed formally)
* Created: 06-Oct-2022
* Last edited: 15-Oct-2022
* License: CC0
* Forking: Hard Fork Needed


Motivation 
----------

The goal of this proposal is to return governance power to miners to give it parity with Ergo’s launch. When Ergo launched, it’s mining algorithm Autolykos
did not support outsourcability, and as such each miner was forced to solo mine. Ergo’s governance model, requiring a 90% supermajority to pass soft and hard forks,
was built with the same assumptions: that each miner would be solo mining and thus would vote for or against changes to the network as they see fit.
With Autolykos 2, non-outsourcability was disabled such that miners could join traditional stratum pools. This changed the assumptions of Ergo’s governance model:
a solo miner now has to compete with pooled miners for blocks (and therefor their right to vote). A miner could choose to join a stratum pool, but are dependent on
the pool developers and their willingness and capability to support a miner’s vote. Furthermore, even if a pool holds an internal vote in some way, the pool in still
limited by the protocol to be either entirely for or against any given change: regardless of a pool’s desire to abide it’s miners' votes accurately, it still must
censor some of them (unless they are unanimous).

By enabling partial voting, mining pools that desire to give governance rights back to miners need only track their miner’s votes, and could submit them directly to
the network. (e.g. 91.56% of the hashrate on GetBlok is in favor of EIP 39 when it mines a block. GetBlok’s submits a block header with that block with the value
of 0.9156 in favour of the fork; WoolyPool mines the next block, 82% in favour, submitting a 0.82 value in favour of the fork; GetBlok mines the next block, this
time their miners indicated 0.931 in favour of the change, etc, etc.)

There is an alternative to hard-forking to achieve similar results but it has large hardware overhead requirement for central pool operators, and requires splitting
the hashrate of traditonal mining pools into smaller fragments. The viability of this no-fork solution should be explored more thoroughly before forcing order on this hard-fork solution, as future decentralized smartpool development could render the need for this EIP obsolete.
The greatest downside to this solution is that the nature of voting occuring over epochs means that miners that choose to support smaller pools, or solo mine using their own nodes, will decrease the odds that blocks mined with their voting preference (when compared with a protcol that can support partial voting). While this solution should be pursured regardless for its benefits to network security, there will always be incentive to join larger traditional pools supporting a miner's preference during voting epochs.

In summary: Disabling non-outsourcability introduced the ability and necessity for pools to censor a nonunanimous group of miners, and an incentive for miners to join pools during voting epochs to have their votes counted. By enabling additional validation logic to count partial votes, we can enable pools to report their miner's votes accurately, mitigate censorship, and return governance power to miners.


The Hard Fork Solution
-------------------------

We introduce new validation logic to the Ergo Node such that miners may optionally report partial support for any given change, while maintaining all other rules. As old nodes would be incapable of recogizing this partial support, a hard fork is required as attempting to soft-fork would likely result in future chainsplitting.

This change will enable pools of miners to indicate their support for given changes provided the pool operator has a method for tracking miner preference.

We can achieve this by changing the boolean nature of votes to allow a range of potential support, and expanding the validation logic to include an additional set of paramaters representing the node's support percentage on each proposed change.

Currently miners vote for any particular change, and any associated paramerters by posting their preference in the block header and extention box respectively. The hard-fork solution will add logic to vote validation that will measure a miner's support for any given change using new data provided in the extension box.


The greatest drawback to this solution is that: While it could be passed via a softfork, doing so would result in future chainsplitting, and as such a hardfork would be required.

Please see the Node Settings section for implementation method.


The No-fork Solution
------------------------
Using the Smart Pools, Sub Pools, and SNISPs designed by GetBlok.io we can create a system wherein a central pool operator can host a pool that both enables smooth mining rewards, and enables it's miners to vote directly on daily and foundational changes to the network.

GetBlok.io's smartpool and subpool contracts are used to create Smart Pools that contain a liquid number of Sub Pools with the following requirements:

-Sub Pools within the smartpool use SNISPs both internally and across the entire Smart Pool

-Sub Pools share block rewards with each other, using the share data across all subpools within the system to calculate and payout subpools and their miners

-Each miner in the Smart Pool is awarded a box by their Sub Pool's payment contract that enables them to sign a contract managed by the Smart Pool with their preferred voting paramaters

-Each Sub Pool has it's own node, (bootstrapped by the pool operator's default)

-The pool operator's default node votes for no changes to the network

-When a miner within the system indicates their desire to vote for any changes using the above mentioned voting contract, their future shares are redirected to a Sub Pool (and node) matching their respective preference

-If no Sub Pools and respective nodes exist within the Smart Pool matching the miner's preference, a new Sub Pool is created by smart contract and a new node is create by the Pool Operator matching the miner's voting preference. (The offchain logic for this crucial step has not yet been built. It can designed by central pool operators and still be compatible with this design in various ways: manually; using containers like docker; using virtual machines; using Flux nodes; using AWS, etc.)

-After confirmation of the first block of a voting epoch, where any potential changes are proposed, Sub Pools and their nodes voting for any changes that are not the proposed change are consolidated back into the default Sub Pool and node indicating a 'no' vote.

https://github.com/GetBlok-io/ergo-smartpooling-contracts
https://github.com/GetBlok-io/Subpooling


  By using Smart Pools to split rewards fairly between Sub Pools managed by their own respective nodes with their own respective voting preferences, not only will all miners within the system will see on average the same rewards as they would mining to a tradtional pool, but they will also have the power to vote on changes to the protocol while supporting their sibling pools with different votes.  
  
While this solution mitigates traditional pool censorship and avoids a hardfork, it has several drawbacks:

-Because voting on Ergo takes places over epochs and a fixed number of votes will see the network upgraded, there exists incentive for miners to consolidate hashrate into larger nodes supporting their voting preference during voting periods. While this solution does at least grant minority voters a method for hashrate/vote consolidation where one may not otherwise exist, they are still at a disadvantage when compared to the hard-fork solution: The hardfork solution allows voting miners to vote in a pool representing a greater percentage of the network's hashpower, maximizing the chance that their vote is counted during the voting epoch.

-This solution increases the hardware overhead for central pool operators; as they will need to host at least one additional node, and an increasing number of nodes up to the hard limits of the sub pooling system, or the number of their miners indicating support for different proposals leading up to the voting epoch. This is feasable up to a point for larger pools, but reduces the ability for smaller pool operators to compete against those with the hardward capacity should miners grow to value their governance power enough that a majority of miners are mining to Smart Pools that enable governance in this way. (This can be mitigated in the future by decentralized solutions that reduce the need for central pool operators.)




General Design
--------------
(Placeholder)




Voting for the Fork
------------------------

(Placeholder)

Activation Details
------------------
(Placeholder)

API Methods Changed
-------------------
(Placeholder)

Node Settings
-------------
This section will detail how the hardfork solution can be implemented.

Disclaimer: The accuracy of the below technical solution is my best guess on how this change could be implemented based on my amateur capacity to parse Scala.

This solution can be implement in one of two ways: either using AVL trees or a Coll/Option of potential support. While the AVL tree method will work great internally for central pool operators to measure their miner's voting preference, the Coll/Option solution at the protocol level is likely preferable for several reasons:

If we exclude the original boolean options in vote counting, [1,0] voting options from our collection, traditional pools that do not desire or have the capacity to measure internal votes can still vote as they currently do by simply excluding partial voting data from their extension box.

This will keep the voting method as consistent with the current method as possible: miners/pools can either submit a vote or abstain and vote counting will still happen naturally.

With a defined range of potential support in our collection, we can fine tune a balance of vote accuracy to data cost, and furthermore create a new everyday voting parameter to modify the accuracy with which votes can be counted (with a reasonable minimum to mitigate censorship). This will enable us to increase the effective number of decimal places in a pool's vote should the network's hashrate grow to a point that pool censorship is taking place, and decrease it should the network reach an equilibrium of hashrate across pools such that all miner's votes are being counted accurately, and thus the data cost can be reduced. In the future, this parameter can be used to derive saturation targets for smart pools.




Below we find some files in the node that must be modified.

https://stackoverflow.com/questions/14822317/logic-operators-for-non-boolean-types-in-scala
A Coll/Option[T] with a range defined between 0.00001 and 1 (or 1-10000 with a stage dividing it later) could work. e.g. Coll[Int] [0-10000] Option[Int]/1000 in place of the current boolean scheme and should allow both nodes that want to vote fully in favor or against to do so, and nodes that want to use a more accurate AVL vote counting method to flatten to match the network's desired accuracy.

source:
https://github.com/ergoplatform/ergo/blob/master/src/main/scala/org/ergoplatform/settings/VotingSettings.scala


This file decides how many votes are required to implement changes to the network for softforks and everyday changes respectively. We will call upon our new parameter "VoteAccuracy" that define a minimum acurracy that votes may be and divide our votesCount and count by the value.

```scala
package org.ergoplatform.settings

case class VotingSettings(votingLength: Int,
                          softForkEpochs: Int,
                          activationEpochs: Int,
                          VoteAccuracy: Int,
                          version2ActivationHeight: Int,
                          version2ActivationDifficultyHex: String) {

  def softForkApproved(votesCount: Int): Boolean = votesCount / VoteAccuracy > votingLength * softForkEpochs * 9 / 10

  def changeApproved(count: Int): Boolean = count / VoteAccuracy > votingLength / 2
}
```

source: 
https://github.com/ergoplatform/ergo/blob/master/src/main/scala/org/ergoplatform/nodeView/state/VotingData.scala



In this file, we will modify the VotingData class to help enable our logic using this as a guide to help us make steps up to the level of accuracy that we desire:


We should no longer be counting (votes + 1) but rather checking for our new paramater, and writing that value to the epochVotes.map

```scala
...

case class VotingData(epochVotes: Array[(Byte, Int)]) {

  def update(voteFor: Byte): VotingData = {
    this.copy(epochVotes = epochVotes.map { case (id, votes) =>
      if (id == voteFor) id -> (votes + 1 ***TO CHANGE***) else id -> votes
    })
  }

  override def canEqual(that: Any): Boolean ***TO CHANGE*** = that.isInstanceOf[VotingData]

  override def equals(obj: scala.Any): Boolean ***TO CHANGE*** = obj match {
    case v: VotingData => v.epochVotes.sameElements(this.epochVotes)
    case _ => false
  }

}

object VotingData {
  val empty = VotingData(Array.empty)
}

object VotingDataSerializer extends ScorexSerializer[VotingData] {

  override def serialize(obj: VotingData, w: Writer): Unit = {
    w.putUShort(obj.epochVotes.length)
    obj.epochVotes.foreach { case (id, cnt) =>
      w.put(id)
      w.putUInt(cnt)
    }
  }

  override def parse(r: Reader): VotingData = {
    val votesCount = r.getUShort()
    val epochVotes = (0 until votesCount).map {_ =>
      r.getByte() -> r.getUInt().toIntExact
    }
    VotingData(epochVotes.toArray)
  }

}
```


source:
https://github.com/ergoplatform/ergo/blob/master/src/main/scala/org/ergoplatform/nodeView/state/ErgoStateContext.scala


As in the above file, we are no longer increasing votes by '1' but rather by a fraction of our new parameter VoteAccuracy as provided by miner data from their extention block.
```scala
...

      extensionOpt match {
        case Some(extension) if epochStarts =>
          processExtension(extension, header, forkVote)(state).map { processed =>
            val params = processed._1
            val extractedValidationSettings = processed._2
            val proposedVotes = votes.map(_ -> 1 ***TO CHANGE***)
            val newVoting = VotingData(proposedVotes)
            new ErgoStateContext(newHeaders, extensionOpt, genesisStateDigest, params,
              extractedValidationSettings, newVoting)(ergoSettings)
          }
        case _ =>
          val newVotes = votes
          val newVotingResults = newVotes.foldLeft(votingData) { case (v, id) => v.update(id) }
          state.result.toTry.map { _ =>
            new ErgoStateContext(newHeaders, extensionOpt, genesisStateDigest, currentParameters, validationSettings,
              newVotingResults)(ergoSettings)
          }
      }
    }.flatten
  }

...

```
Again, no longer are we increasing votes by increments of 1, but the corresponding value of our new parameter. The logic here must also be modified so as the include checking for our new parameter.
```
    * Check that non-zero votes extracted from block header are correct
    */
  private def validateVotes(header: Header): ValidationState[ErgoStateContext] = {
    val votes: Array[Byte] = header.votes.filter(_ != Parameters.NoParameter)
    val epochStarts = header.votingStarts(votingSettings.votingLength)
    val votesCount = votes.count(_ != Parameters.SoftFork)
    val reverseVotes: Array[Byte] = votes.map(v => (-v).toByte)

    @inline def vs: String = votes.mkString("")

    ModifierValidator(validationSettings)
      .payload(this)
      .validate(hdrVotesNumber, votesCount <= Parameters.ParamVotesCount, InvalidModifier(s"votesCount=$votesCount", header.id, header.modifierTypeId))
      .validateSeq(votes) { case (validationState, v) =>
        validationState
          .validate(hdrVotesDuplicates, votes.count(_ == v) == 1, InvalidModifier(s"Double vote in $vs", header.id, header.modifierTypeId))
          .validate(hdrVotesContradictory, !reverseVotes.contains(v), InvalidModifier(s"Contradictory votes in $vs", header.id, header.modifierTypeId))
          .validate(hdrVotesUnknown, !(epochStarts && !Parameters.parametersDescs.contains(v)), InvalidModifier(s"Incorrect vote proposed in $vs", header.id, header.modifierTypeId))
      }
  }

}
...
```


source:https://github.com/ergoplatform/ergo/blob/master/src/main/scala/org/ergoplatform/settings/Parameters.scala


In the Parameters section we add our new adjustable parameter that is used to help calculate the accuracy of pool's votes.
```scala
class Parameters(val height: Height,
                 val parametersTable: Map[Byte, Int],
                 val proposedUpdate: ErgoValidationSettingsUpdate)
  extends ErgoLikeParameters {

  import Parameters._
...
/**
    * Accuracy of voting data (as decical)
    */
lazy val VotingAccuracy: Int = parametersTable(VotingAccuracyIncrease)

  def update(height: Height,
             forkVote: Boolean,
             epochVotes: Seq[(Byte, Int)],
             proposedUpdate: ErgoValidationSettingsUpdate,
             votingSettings: VotingSettings): (Parameters, ErgoValidationSettingsUpdate) = {
    val (table1, activatedUpdate) = updateFork(height, parametersTable, forkVote, epochVotes, proposedUpdate, votingSettings)
    val table2 = updateParams(table1, epochVotes, votingSettings)
    (Parameters(height, table2, proposedUpdate), activatedUpdate)
  }
  
...
object Parameters {
...
  //Parameter identifiers
...
  val MaxVotingAccuracyIncrease: Byte = 9
  val MaxVotingAccuracyDecrease: Byte = (-VotingAccuracyIncrease).toByte
...
  val MaxVotingAccuracyDefault: Int = 10000 //0.00001 % of a pool's hashpower
  val MaxVotingAccuracyStep: Int = 100 //Including a step can help to prevent an attack on miner governance
  val MaxVotingAccuracyMin: Int = 1 //Changing this value to 1 would disable partial voting
...
  val DefaultParameters: Map[Byte, Int] = Map(
   ...
    MaxVotingAccuracyIncrease -> VotingAccuracyDefault,
    BlockVersion -> 1
  )
...
  val parametersDescs: Map[Byte, String] = Map(
    ...
    MaxVotingAccuracyIncrease -> "Maximum allowed voting accuracy (A vote 100% in favour should fill this value)"
  )
...
  val stepsTable: Map[Byte, Int] = Map(
  ...
    MaxVotingAccuracyIncrease -> MaxVotingAccuracyIncreaseStep,
  )
...
val minValues: Map[Byte, Int] = Map(
    ...
    MaxVotingAccuracyIncrease -> MaxVotingAccuracyIncreaseMin,
  )
```
Testnet Data
------------ 

(Placeholder)

Mainnet Data
------------

(Placeholder)

References
----------

(Placeholder)
